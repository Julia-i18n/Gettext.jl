var documenterSearchIndex = {"docs":
[{"location":"i18n/#Internationalization-(i18n)-API","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"","category":"section"},{"location":"i18n/#Marking-strings-for-translation","page":"Internationalization (i18n) API","title":"Marking strings for translation","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"The most basic i18n task is to mark every user-visible string for possible translation.  This is typically done with the macros describe in the following subsections.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"(Note: we use macros, rather than functions, so that they can automatically substitute the current __GETTEXT_DOMAIN__ when used in a module.)","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"See also the GNU gettext manual's tips on how to prepare translatable strings in your code.  In short, they recommend translating entire English sentences/paragraphs (avoiding forming sentences by concatenation), splitting at paragraphs, with placeholders for interpolation/substitution (see below).","category":"page"},{"location":"i18n/#Simple-literal-strings:-_\"...\"","page":"Internationalization (i18n) API","title":"Simple literal strings: _\"...\"","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"For most literal strings, you can simply replace \"...\" with _\"...\", i.e. prepend an underscore.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"_\"...\" acts just like an ordinary Julia literal string, but internally it corresponds to a call to @gettext(\"...\"), returning a translated string if appropriate (assuming a translation exists for the current locale).   The only other big difference from a typical Julia string is that $ interpolation is not supported in _\"...\" (any $ is treated literally).  This is intentional: translation strings should not depend on runtime values, because a .po file contains only a finite number of translations, so runtime interpolation should be employed judiciously as described below.","category":"page"},{"location":"i18n/#Interpolating-into-translated-strings","page":"Internationalization (i18n) API","title":"Interpolating into translated strings","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"If you need to substitute another value into a translation, the standard practice is to put a a printf-like placeholder (e.g. %s or %d) into the string, and then substitute it after translation.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"For example, suppose that your program outputs the string \"Congratulations!  You won $prize!\", where $prize substitutes some other Julia string prize, like prize=\"a yacht\" or prize=\"$100.  To i18n this string, one strategy might be:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"replace(_\"Congratulations!  You won %s!\", \"%s\"=>@gettext(prize))","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"This way, it looks up a single string \"Congratulations!  You won %s!\" in the .po file, and the translation should also have the %s placeholder.  (For example, the Spanish translation might be \"¡Felicidades, ganaste %s!\".)   Here, we also call @gettext to look up the translation (if any) for the runtime value of prize — presumably, there might be translations for a finite number of cases like \"a yacht\", while other strings like $100 could be left as-is.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Here, we are using Julia's built-in replace function.  To perform more complicated string-formatting substitutions, one could instead use the Printf standard library, or perhaps Python-style format strings via the Format.jl package.","category":"page"},{"location":"i18n/#Interpolating-runtime-singular-or-plural-forms:-@ngettext","page":"Internationalization (i18n) API","title":"Interpolating runtime singular or plural forms: @ngettext","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"What if you want to translate a string like \"Your birthday is in $n days.\", where if n == 1 it should instead use a singular noun?  (And some languages might have a specialized plural for n == 2 as well.)","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"In this case, a simple placeholder for n is not enough.  Instead, you can use the macro @ngettext, which allows separate singular and plural translations:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"@ngettext(\"Your birthday is in %d day.\", \"Your birthday is in %d days.\", \"%d\"=>n)","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Here, we provide both singular and plural forms of the string to be translated, and @ngettext will choose one based on the runtime value of n.  (In fact, for some languages, gettext may choose among multiple plural forms.)   The translation strings should also have a %d placeholder, and the \"%d\"=>n argument tells @ngettext to substitute string(n) for %d in the final result (using replace).","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"If you want to perform more complicated numeric formatting on your own, e.g. with Printf, you can pass n instead of \"%d\"=>n and no substitution will be performed on the result.","category":"page"},{"location":"i18n/#Providing-additional-translation-context:-@pgettext","page":"Internationalization (i18n) API","title":"Providing additional translation context: @pgettext","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Sometimes, the same string might be used in different contexts in a program that require different translations. This is especially common for very short strings (e.g. single words).  For example, the string \"Open\" in a File menu might be translated into Spanish as a verb \"Abrir\" (to open a file), but the same string might be translated as an adjective \"Abierto\" to indicate that a door is open in a game.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"To support this case, Gettext allows you to pass an additional context string for a translation, using the macro @pgettext.  For example:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"@pgettext(\"File menu\", \"Open\")  # translate \"Open\" in the File menu\n@pgettext(\"Door\", \"Open\")       # translate an \"Open\" sign attached to a door","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Similarly, there is a macro @npgettext that is like @ngettext but has an additional context string as the first argument.","category":"page"},{"location":"i18n/#Macro-reference","page":"Internationalization (i18n) API","title":"Macro reference","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"The following are the string-i18n macros:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Gettext.@__str\nGettext.@gettext\nGettext.@ngettext\nGettext.@pgettext\nGettext.@npgettext\nGettext.@N__str","category":"page"},{"location":"i18n/#Gettext.@__str","page":"Internationalization (i18n) API","title":"Gettext.@__str","text":"_\"...\"\n\nReturns the translation (if any) for the given literal string \"...\" via @gettext.\n\nThis string can contain backslash escapes like ordinary Julia literal strings, but $ is treated literally (not used for interpolations): translation strings should not generally contain runtime values.\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#Gettext.@gettext","page":"Internationalization (i18n) API","title":"Gettext.@gettext","text":"@gettext(msgid::AbstractString)\n\nLook up the translation (if any) of msgid, returning the translated string, or returning msgid if no translation was found.\n\nIn a module != Main, this passes the module's __GETTEXT_DOMAIN__ as the domain argument to gettext, whereas the global textdomain is used in the Main module.\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#Gettext.@ngettext","page":"Internationalization (i18n) API","title":"Gettext.@ngettext","text":"@ngettext(msgid::AbstractString, msgid_plural::AbstractString, n::Integer)\n@ngettext(msgid::AbstractString, msgid_plural::AbstractString, nsub::Pair{<:AbstractString, <:Integer})\n\nLook up the translation (if any) of msgid, with the plural form given by msgid_plural, returning the singular form if n == 1 and a plural form if n != 1 (n must be nonnegative), giving a translated string if available.\n\nInstead of passing an integer n, you can pass a Pair placeholder=>n, in which case case the string placeholder is replaced by n in the returned string; most commonly, placeholder == \"%d\" (in printf style).  (Note that this is a simple string replacement; if you want more complicated printf-style formating like \"%05d\" then you will need to call a library like Printf yourself.)\n\nIn a module != Main, this passes the module's __GETTEXT_DOMAIN__ as the domain argument to ngettext, whereas the global textdomain is used in the Main module.\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#Gettext.@pgettext","page":"Internationalization (i18n) API","title":"Gettext.@pgettext","text":"@pgettext([domain::AbstractString], context::AbstractString, msgid::AbstractString)\n\nLike @gettext, but also supplies a context string for looking up msgid, returning the translation (if any) or msgid (if no translation was found).\n\nIn a module != Main, this passes the module's __GETTEXT_DOMAIN__ as the domain argument to pgettext, whereas the global textdomain is used in the Main module.\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#Gettext.@npgettext","page":"Internationalization (i18n) API","title":"Gettext.@npgettext","text":"@npgettext(context::AbstractString, msgid::AbstractString, msgid_plural::AbstractString, n::Integer)\n@npgettext(context::AbstractString, msgid::AbstractString, msgid_plural::AbstractString, nsub::Pair{<:AbstractString, <:Integer})\n\nLike @ngettext, but also supplies a context string for looking up msgid or its plural form msgid_plural (depending on n), optionally performing a text substitution if a Pair is passed for the final argument.\n\nIn a module != Main, this passes the module's __GETTEXT_DOMAIN__ as the domain argument to npgettext, whereas the global textdomain is used in the Main module.\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#Gettext.@N__str","page":"Internationalization (i18n) API","title":"Gettext.@N__str","text":"N_\"...\"\n\n\"No-op\" translation, equivalent to \"...\", for strings that do not require translation.\n\nThis string can contain backslash escapes like ordinary Julia literal strings, but $ is treated literally (not used for interpolations).\n\n(The main use of this macro is to explicitly mark strings to ensure that they are excluded from automated translation tools.)\n\n\n\n\n\n","category":"macro"},{"location":"i18n/#domains","page":"Internationalization (i18n) API","title":"Domains","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Every translation in Gettext is relative to a \"domain\", which usually corresponds to a single program or package.  Each domain has a list of strings to be translated, and can have domain.po files that give translations for particular locales (see Localization (l10n) and PO files).   To control the domain being used, you need to do two things:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Call bindtextdomain to specify the path of the po directory containing translations for that domain.  This is typically done in a module's __init__ function (see below).\nSpecify the domain you are using: this is done via the __GETTEXT_DOMAIN__ constant in modules/packages (below), or is done by setting a global domain with textdomain for code running in Julia's Main module (scripts and interactive work).","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Gettext.bindtextdomain\nGettext.textdomain","category":"page"},{"location":"i18n/#Gettext.bindtextdomain","page":"Internationalization (i18n) API","title":"Gettext.bindtextdomain","text":"bindtextdomain(domain::AbstractString, [path::AbstractString])\n\nSpecify that the po directory for domain is at path (if supplied), returning the current (absolute) path for domain.\n\n(If this function is not called, then gettext will look in a system-specific directory like /usr/local/share/locale for translation catalogs.)\n\n\n\n\n\n","category":"function"},{"location":"i18n/#Gettext.textdomain","page":"Internationalization (i18n) API","title":"Gettext.textdomain","text":"textdomain([domain::AbstractString])\n\nSet the global Gettext domain to domain (if supplied), returning the current global domain.\n\nThis domain is used for calls to low-level functions like gettext when no domain argument is passed, and also for macros like _\"...\" and @getext when used from the Main module.\n\n\n\n\n\n","category":"function"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"See also Locating Message Catalog Files in the GNU gettext manual.","category":"page"},{"location":"i18n/#module_gettext","page":"Internationalization (i18n) API","title":"Gettext for modules and packages","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"To use Gettext.jl in a module MyModule, especially in a Julia package, at the beginning of your module you should define a const __GETTEXT_DOMAIN__ to a unique domain name for your package's translations, and in your top-level module's __init__ function you should call bindtextdomain to specify the path to your package's po directory (see Localization (l10n) and PO files), typically at the top level of your package.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"It should look something like this:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"module MyModule\n\nusing Gettext\nconst __GETTEXT_DOMAIN__ = \"MyModule-<uuid>\" # replace with package UUID\nfunction __init__()\n    bindtextdomain(__GETTEXT_DOMAIN__, joinpath(@__DIR__, \"..\", \"po\"))\nend\n\n# ...module implementation...\n\nend","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"In \"MyPackage-<uuid>\", the <uuid> denotes the unique UUID identifier of your package — this ensures that two packages will not have the same gettext domain, even if they happen to have the same name.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"When they are used in any module (other than Julia's implicit Main module for scripts and interactive work), the macros, _\"...\", @gettext, and so on (see above) pass this global variable __GETTEXT_DOMAIN__ to the corresponding low-level functions.  You will get an UndefVarError if you use those macros in a module that does not define __GETTEXT_DOMAIN__.  (In the Main module, the same macros instead use the global textdomain.)","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"The bindtextdomain call in the example above assumes that you have a top-level directory po in your package, which is a good default location.  This directory is used to store translation (.po) files po/<locale>/LC_MESSAGES/MyModule-<uuid>.po, where <locale> is the standard locale identifier, e.g. en (English) or en_GB (English, Great Britain), and MyModule-<uuid> is your domain name from above.","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"If your package has submodules, in most cases they can simply employ the same domain as your top-level module MyModule, via:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"using Gettext\nusing ..MyModule: __GETTEXT_DOMAIN__`","category":"page"},{"location":"i18n/#Lower-level-API","page":"Internationalization (i18n) API","title":"Lower-level API","text":"","category":"section"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"The following lower-level API functions can be used instead of the macros for the rare cases in which you want more manual control over the Gettext domain:","category":"page"},{"location":"i18n/","page":"Internationalization (i18n) API","title":"Internationalization (i18n) API","text":"Gettext.gettext\nGettext.ngettext\nGettext.pgettext\nGettext.npgettext","category":"page"},{"location":"i18n/#Gettext.gettext","page":"Internationalization (i18n) API","title":"Gettext.gettext","text":"gettext([domain::AbstractString], msgid::AbstractString)\n\nLook up the translation (if any) of msgid in domain (if supplied, or in the global textdomain otherwise), returning the translated string, or returning msgid if no translation was found.\n\nSee also @gettext to use the domain of the current module.\n\n\n\n\n\n","category":"function"},{"location":"i18n/#Gettext.ngettext","page":"Internationalization (i18n) API","title":"Gettext.ngettext","text":"ngettext([domain::AbstractString], msgid::AbstractString, msgid_plural::AbstractString, n::Integer)\nngettext([domain::AbstractString], msgid::AbstractString, msgid_plural::AbstractString, nsub::Pair{<:AbstractString, <:Integer})\n\nLook up the translation (if any) of msgid in domain (if supplied, or in the global textdomain otherwise), with the plural form given by msgid_plural, returning the singular form if n == 1 and a plural form if n != 1 (n must be nonnegative), giving a translated string if available.\n\nInstead of passing an integer n, you can pass a Pair placeholder=>n, in which case case the string placeholder is replaced by n in the returned string; most commonly, placeholder == \"%d\" (in printf style).  (Note that this is a simple string replacement; if you want more complicated printf-style formating like \"%05d\" then you will need to call a library like Printf yourself.)\n\nSee also @ngettext to use the domain of the current module.\n\n\n\n\n\n","category":"function"},{"location":"i18n/#Gettext.pgettext","page":"Internationalization (i18n) API","title":"Gettext.pgettext","text":"pgettext([domain::AbstractString], context::AbstractString, msgid::AbstractString)\n\nLike gettext, but also supplies a context string for looking up msgid (in domain, if supplied, or the global textdomain otherwise), returning the translation (if any) or msgid (if no translation was found).\n\nSee also @pgettext to use the domain of the current module.\n\n\n\n\n\n","category":"function"},{"location":"i18n/#Gettext.npgettext","page":"Internationalization (i18n) API","title":"Gettext.npgettext","text":"npgettext([domain::AbstractString], context::AbstractString, msgid::AbstractString, msgid_plural::AbstractString, n::Integer)\nnpgettext([domain::AbstractString], context::AbstractString, msgid::AbstractString, msgid_plural::AbstractString, nsub::Pair{<:AbstractString, <:Integer})\n\nLike ngettext, but also supplies a context string for looking up msgid or its plural form msgid_plural (depending on n), optionally performing a text substitution if a Pair is passed for the final argument.\n\nSee also @npgettext to use the domain of the current module.\n\n\n\n\n\n","category":"function"},{"location":"#Gettext.jl","page":"Home","title":"Gettext.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers facilities for internationalization and localization (i18n and l10n) of software in the Julia programming language, using the standard gettext system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(This package calls GNU gettext's libintl library directly from Julia, via the GettextRuntime_jll package compiled for Julia by Yggdrasil; this is automatically installed for you by Julia's package manager.  GNU gettext is free/open-source software licensed under the GNU LGPL.)","category":"page"},{"location":"#Overview-of-internationalization-and-localization","page":"Home","title":"Overview of internationalization and localization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Internationalization (commonly abbreviated i18n) is the process of making computer software able to support translations into multiple languages.  Localization (abbreviated l10n) is the creation of a specific translation for a particular language and cultural setting (a locale).","category":"page"},{"location":"","page":"Home","title":"Home","text":"gettext is a popular system, dating back to 1990, for i18n and l10n of messages (strings) exposed to users in a program's interface: prompts, menu items, error messages, and so on.  This consists of two parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"i18n: in your program, any string that might need translation should be wrapped in a call to a gettext function.   In Gettext.jl, this is usually accomplished by macros: For a typical string \"...\", you simply replace it with _\"...\" to make it translatable.  There are also more specialized macros, such as @ngettext for strings with runtime-dependent singular and plural forms.  See the Internationalization (i18n) API chapter.\nl10n: for any locale, one can create a .po file that lists the translations of strings in a human-readable text format — this format is designed so that non-programmers can easily contribute translations, and there are many software tools to help create .po files (either manually or via automated translation).   These .po files are then placed in a standardized directory for your package, and are converted to a binary .mo format with the GNU msgfmt program.   At runtime, Gettext.jl then automatically looks up translations (if any) from the current locale (as indicated by the operating system) and substitutes them for strings like _\"...\" in your program.  See the Localization (l10n) and PO files chapter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Other forms of i18n and l10n, such as locale-specific formatting of numbers and dates, are outside the scope of gettext, but are provided by other libraries such as libc.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the introduction and overview from the GNU gettext manual.","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose that you have the following Julia program","category":"page"},{"location":"","page":"Home","title":"Home","text":"println(\"Hello, world!\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To i18n it, the first step is simply to change the code to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gettext\nprintln(_\"Hello, world!\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"which tells Gettext.jl to translate the string \"Hello, world!\" for the current locale, if possible.   By default, if no translation is found, _\"...\"  will simply return the original untranslated string, and the program will have the same output as before.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Gettext.jl package comes with a sample .po translation file that includes a translation of \"Hello, world!\" into French.    In particular, the Gettext.jl package has a text file po/fr/LC_MESSAGES/sample.po (along with its binary-format equivalent po/fr/LC_MESSAGES/sample.mo) that includes the translation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"msgid \"Hello, world!\"\nmsgstr \"Bonjour le monde !\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, in the sample.po file, the msgid is the original string and msgstr is the translation.  The po directory (typically at the top level of the package) is where a package's translations are placed, and po/fr/LC_MESSAGES contains translations for French-language (fr) locales in the default \"category\" LC_MESSAGES.  Inside this directory, sample.po contains the translations for the \"domain\" we called \"sample\" — there will typically be one such domain per independent package/component of a program (see Gettext for modules and packages).   We need to tell Gettext.jl where to find the translations we are using, which we could do here via:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gettext\nbindtextdomain(\"sample\", joinpath(dirname(pathof(Gettext)), \"..\", \"po\"))\ntextdomain(\"sample\") # set domain for the global Main module only\n\nprintln(_\"Hello, world!\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, bindtextdomain specifies the path of the po directory for a given domain.  For scripts (or interactive sessions) running in Julia's Main module, you then call textdomain to set the global domain.   Inside packages and other modules, you instead define a __GETTEXT_DOMAIN__ global to set a package-specific domain, so that each package can have independent translations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, when you run the code, you will still see \"Hello, world!\" if you are in any non-French locale, but French locales will instead print \"Bonjour le monde !\". On Unix-like systems, you can set the locale simply via the LANGUAGE environment variable. This can even be changed at runtime, so","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Gettext\nbindtextdomain(\"sample\", joinpath(dirname(pathof(Gettext)), \"..\", \"po\"))\ntextdomain(\"sample\")\n\nprintln(_\"Hello, world!\")\nENV[\"LANGUAGE\"]=\"fr\"\nprintln(_\"Hello, world!\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"will print","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hello, world!\nBonjour le monde !","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you are in a non-French locale to start with.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Note: Microsoft Windows has its own API to set the locale, not via environment variables, so you may not see French output unless you change the Windows display language.)","category":"page"},{"location":"l10n/#Localization-(l10n)-and-PO-files","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"","category":"section"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Once you have internationalized your code by marking translatable strings (see Internationalization (i18n) API), you are ready to start creating translations: this is localization (l10n) of your program, which is achieved by authoring a .po file with a list of translated strings.","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"In fact, the .po files need not be created by the programmer — they can instead be contributed by users, which allows native speakers of other languages to help you out.   There are numerous software tools to help people create and edit .po files, some of which we mention below.","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Localization involves three components: setting up the po directory to hold translations, extracting the strings to be translated, and creating/editing .po files for various locales.   We summarize each of these components below.","category":"page"},{"location":"l10n/#The-po-directory","page":"Localization (l10n) and PO files","title":"The po directory","text":"","category":"section"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Every Julia package or program should set up a po directory to contain its translation files.  (For Julia packages, this is typically located in the top level of the package directory, as described in Gettext for modules and packages.)  The po directory's location is configured by a call to bindtextdomain in the code (see Domains).","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"The po directory will initially be empty, but each new localization should add two files:","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"po/<locale>/LC_MESSAGES/<domain>.po\npo/<locale>/LC_MESSAGES/<domain>.mo","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Here, <locale> is the name of the locale (language and culture) of the localization, typically of the form ll or ll_CC, where ll is the two-letter language code (e.g. en for English or fr for French), and CC is the two-letter code of a country or territory (e.g. en_GB would indicate localization for British English).  See also Locale Names in the GNU gettext manual.\n<domain> is the name of the Gettext domain used by the program or package (see Domains), typically the name of the program or package followed by a unique identifier like a UUID; for a package/module, this is the value of __GETTEXT_DOMAIN__.\nThe <domain>.po file is a human-readable/editable text file containing the translated messages.   The <domain>.mo file is a condensed binary representation of the <domain>.po data, which can be generated from <domain>.po by the GNU msgfmt program.","category":"page"},{"location":"l10n/#Extracting-the-strings-to-be-translated","page":"Localization (l10n) and PO files","title":"Extracting the strings to be translated","text":"","category":"section"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"The strings to be translated consist of every call to the localization macros _\"...\", @ngettext, and so on in the program or package (see Internationalization (i18n) API).","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Currently, this list of strings must be extracted manually, but in the near future we hope to automate this process.  See: Gettext.jl#22.","category":"page"},{"location":"l10n/#Creating/editing-.po-files","page":"Localization (l10n) and PO files","title":"Creating/editing .po files","text":"","category":"section"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Once a list of strings has been extracted, typically in the form of a \"template\" .pot file that contains the empty translations (\"\"), there are various ways that you can edit/create .po files:","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"Hand editing: the format is human-readable; see also this tutorial and this sample.po file included with Gettext.jl.\nVarious software packages provide .po editor tools, including: Virtaal, Poedit, Gtranslator, Lokalize\nZanata and Weblate are web-based platforms for collaborating with translators, both of which support .po files.\nVarious packages to auto-generate translations: e.g. using Google translate, using LLMs\nTranslation Toolkit provides a number of other automation utilities for .po files.","category":"page"},{"location":"l10n/","page":"Localization (l10n) and PO files","title":"Localization (l10n) and PO files","text":"(We hope that this is a useful list of resources, but currently make no specific recommendations.)","category":"page"}]
}
